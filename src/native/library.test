#include <iostream>
#include "xdbc_XClient.h"
#include <xclient.h>
#include <thread>
#include <chrono>
#include <cstring>
#include <fstream>
#include <nlohmann/json.hpp>
/*
 * Class:      xdbc_Library_00024
 * Method:     load
 * Signature:  (Ljava/lang/String;)I
 */

 std::vector <xdbc::SchemaAttribute> createSchemaFromConfig(const std::string &configFile) {
     std::ifstream file(configFile);
     if (!file.is_open()) {
         std::cout << "failed to open schema" << configFile << std::endl;

     }
     nlohmann::json schemaJson;
     file >> schemaJson;

     std::vector <xdbc::SchemaAttribute> schema;
     for (const auto &item: schemaJson) {
         schema.emplace_back(xdbc::SchemaAttribute{
                 item["name"],
                 item["type"],
                 item["size"]
         });
     }
     return schema;
 }
 std::string readJsonFileIntoString(const std::string &filePath) {
     std::ifstream file(filePath);
     if (!file.is_open()) {
         std::cout << "failed to open schema" << filePath << std::endl;
         return "";
     }

     std::stringstream buffer;
     buffer << file.rdbuf();

     return buffer.str();
 }

JNIEXPORT jlong JNICALL Java_xdbc_XClient_initialize
(JNIEnv *env, jobject clazz, jstring tableName) {

    //const char* name_chars = env->GetStringUTFChars(name,0);

    xdbc::RuntimeEnv xdbcEnv;
    xdbcEnv.env_name = "Spark Client";
    xdbcEnv.table = "lineitem_sf10";
    xdbcEnv.iformat = 2;
    xdbcEnv.buffer_size = 1024;
    xdbcEnv.buffers_in_bufferpool = 65534 / xdbcEnv.buffer_size;
    xdbcEnv.sleep_time = std::chrono::milliseconds(2);
    xdbcEnv.rcv_parallelism = 1;
    xdbcEnv.write_parallelism = 1;
    xdbcEnv.decomp_parallelism = 1;
    xdbcEnv.transfer_id = 0;

    xdbcEnv.server_host = "xdbcserver";
    xdbcEnv.server_port = "1234";

    //create schema
    std::vector <xdbc::SchemaAttribute> schema;

    std::string schemaFile = "/xdbc-client/tests/schemas/" + xdbcEnv.table + ".json";

    schema = createSchemaFromConfig(schemaFile);
    xdbcEnv.schemaJSON = readJsonFileIntoString(schemaFile);
    xdbcEnv.schema = schema;

    xdbcEnv.tuple_size = std::accumulate(xdbcEnv.schema.begin(), xdbcEnv.schema.end(), 0,
                                     [](int acc, const xdbc::SchemaAttribute &attr) {
                                         return acc + attr.size;
                                     });

    xdbcEnv.tuples_per_buffer = xdbcEnv.buffer_size * 1024 / xdbcEnv.tuple_size;

    xdbc::XClient* c = new xdbc::XClient(xdbcEnv);

    const char* tableName_chars = env->GetStringUTFChars(tableName,0);
    std::cout << "Entered" << std::endl;

    std::cout << "Made XClient called: " << xdbcEnv.env_name << std::endl;

    c->startReceiving(tableName_chars);

    std::cout << "Started receiving " << std::endl;
        /*int cnt = 0;

        std::cout << "Started receive" << std::endl;

        //auto start = std::chrono::steady_clock::now();
        //wait to start receiving
        std::cout << "Waiting to start transfer" << std::endl;
        while (!c.hasUnread()) {
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
        }

        int buffsRead = 0;
        while (c.hasUnread()) {
            //cout << "Started iteration" << endl;
            xdbc::buffWithId curBuffWithId = c.getBuffer();
            for (auto sl: curBuffWithId.buff) {
                std::cout << sl.l_orderkey << std::endl;
            }
        }*/

    env -> ReleaseStringUTFChars(tableName, tableName_chars);
    return reinterpret_cast<jlong>(c);
}

/*
 * Class:      xdbc_XClient
 * Method:     hasNext
 * Signature:  (J)I
 */
JNIEXPORT jint JNICALL Java_xdbc_XClient_hasNext0
  (JNIEnv *env, jobject clazz, jlong pointer)
  {
    xdbc::XClient* c = (xdbc::XClient*) pointer;
    if(c->hasNext(0))
        return 1;

    return 0;
  }

/*
 * Class:      xdbc_XClient
 * Method:     getBuffer
 * Signature:  (J)J
 */
JNIEXPORT jint JNICALL Java_xdbc_XClient_getBuffer0
  (JNIEnv* env, jobject clazz, jlong pointer, jobject resBuf)
  {
      jbyte* res = (jbyte*) env->GetDirectBufferAddress(resBuf);

      xdbc::XClient* c = (xdbc::XClient*) pointer;

      xdbc::buffWithId curBuffWithId = c->getBuffer(0);

      long cnt = 0;

      char *ptr = reinterpret_cast<char *>(curBuffWithId.buff);
      for (int i = 0; i < curBuffWithId.totalTuples; ++i) {
        //TODO: fix

        //std::memcpy(res+(cnt*48), &sl, 48);
        cnt++;

      }

      if(cnt!=1000)
        std::cout << "wrote: " << cnt*48 << std::endl;
      jclass cls = env->GetObjectClass(resBuf);
      jmethodID mid = env->GetMethodID(cls, "limit", "(I)Ljava/nio/Buffer;");
      env->CallObjectMethod(resBuf, mid, cnt*48);

      return curBuffWithId.id;
  }

/*
 * Class:      xdbc_XClient
 * Method:     markBufferAsRead
 * Signature:  (JI)I
 */
JNIEXPORT jint JNICALL Java_xdbc_XClient_markBufferAsRead0
  (JNIEnv *env, jobject clazz, jlong pointer, jint bufferId)
  {
      xdbc::XClient* c = (xdbc::XClient*) pointer;
      c->markBufferAsRead(bufferId);
      return 1;
  }
